# -*- coding: utf-8 -*-
"""Untitled.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16tipq8-DlkXj_UNIegybOjJBLbuU2yGf
"""

import math
from datetime import datetime
from typing import Union, List

import numpy as np
import pandas as pd

def z_norm_dist(x: np.array, y: np.array) -> float:
    # x /= np.linalg.norm(x)
    # y /= np.linalg.norm(y)
#     print(f'inside z-nom {math.sqrt(2*len(x)*(1-np.corrcoef(x, y)[0][1]))}')
    # ******songer à tester sans la distance normale ajoutée  pour voir l plus de la distance proposée
    return np.linalg.norm(x - y)*math.sqrt(2*len(x)*(1-np.corrcoef(x, y)[0][1]))


def distance(a: np.array, b: np.array) -> float:
    """
    Args:
            a (np.array): vector
            b (np.array): vector

    Returns:
            float : z_normalized distance between a and b
    """
    # ******songer à tester sans la distance normale ajoutée  pour voir l plus de la distance proposée
    a = a/np.norm(a)
    b = b/np.norm(b)
    return z_norm_dist(a, b)

class Cluster:
    def __init__(self, subsequences: np.array, max_size: int, distance=z_norm_dist) -> None:
        self.activity = datetime.now()
        if len(subsequences.shape) == 1:
            self.items = [subsequences]
        else:
            self.items = list(subsequences)
        self.size = max_size
        self.distance = distance

    def __len__(self):
        return len(self.items)

    def __str__(self) -> str:
        return str(self.items)

    def __repr__(self) -> str:
        return f"Cluster({self.items})"

    def add_item(self, sub_sequence: np.array, r: float) -> None:
        self.activity = datetime.now()
        already_exist = any(np.array_equal(sub_sequence, i)
                            for i in self.items)

        if len(self) < self.size and not already_exist:
            self.items.append(sub_sequence)

        elif not already_exist:
            # if there is a subsequence which is too near another subsequence, we can remove it . we can do it because l'inégalité triangulaire est vérifiée
            dist_matrice = np.array([
                [self.distance(i, j) for i in self.items] for j in self.items
            ])
            min_dist = dist_matrice[dist_matrice != 0].min()
            ij_min = np.where(dist_matrice == min_dist)[0]
            ij_min = tuple([i.item() for i in ij_min])
            if r > min_dist:
                self.items[ij_min[0]] = sub_sequence


class ClusterManager:
    def __init__(self, subsequence: Union[np.array, None], max_nb_clusters: int, r, p: int = 4, distance=z_norm_dist):
        self.p = 4
        self.cluster_number = max_nb_clusters
        self.r = r
        if subsequence:
            self.clusters = [Cluster(subsequence, p)]
        else:
            self.clusters = []
        self.max_clusters = max_nb_clusters
        self.distance = distance

    def __str__(self) -> str:
        return f'{self.clusters}'

    @property
    def clusters_activity(self) -> List[datetime]:
        return [c.activity for c in self.clusters]

    def add_new_cluster(self, subsequence):
        if len(self.clusters) > self.max_clusters:
            min_index = self.clusters_activity.index(
                min(self.clusters_activity))
            # print(
            #     f"{'*'*10}.This is the cluster that had the lowest activity", min_index, self.clusters_activity
            # )
            self.clusters.pop(min_index)
        self.clusters.append(Cluster(subsequence, self.p))

    def clustering(self, subsequence, d_list=[]):
        min_dist = float('inf')
        cluster_id = -1
        # try to identify its cluster
        for i, cluster in enumerate(self.clusters):
            for clustroid in cluster.items:
                d = self.distance(clustroid, subsequence)
                if d < self.r:
                    # print(f"{'*'*10}, it entered a cluster")
                    if d < min_dist:
                        min_dist = d
                        cluster_id = i
            d_list.append((i, min_dist))
        # try to know if it can be the centroid
        if cluster_id != -1:
            self.clusters[cluster_id].add_item(subsequence, self.r)
            return False, min_dist
        else:
            return True, min_dist

class DragStream:
    def __init__(self, r, nbr_cluster, training_period, p=4, distance=z_norm_dist) -> None:
        self.data = []
        self.r = r
        self.nbr_cluster = nbr_cluster
        self.training_period = training_period + 1
        self.p = p
        self.cluster_manager = ClusterManager(None, nbr_cluster, r, p)
        self.discords = []
        self._first_learn = True
        self.distance = distance

    def _ajust_threshold(self):
        if len(self.discords) > 1:
            dist_ = []
            for i in range(len(self.discords)):
                for j in range(i+1, len(self.discords)):
                    dist_.append(self.distance(
                        self.discords[i], self.discords[j]))
            print(self.r)
            self.r = 48
            print(self.r)

    def score_one(self, x: np.array):
        # print(len(self.discords))
        self.data.append({
            'distance_to_discord':[],
            'distance_to_cluster':[]
        })
        if self._first_learn:
            self._first_learn = False
            self.cluster_manager.add_new_cluster(x)
            self.discords.append(x)
            print(f'Seuil: {self.r} || Outlier: {True} ||dist_cluster {[]}|| dist_discord: {self.data[-1]["distance_to_discord"]} || {x} || ')
            
            return -1

        isCandidate = True
        min_dist_if_discord = float('inf')
        if self.training_period > 0:
            self.training_period -= 1
        l = []
        for c in self.discords:
            d = self.distance(x, c)
            self.data[-1]['distance_to_discord'].append(d)
            min_dist_if_discord = min(min_dist_if_discord, d)
            if d < self.r:
                isCandidate = False
            else:
                l.append(c)

        self.discords = l

        isOutlier, dist_to_cluster = self.cluster_manager.clustering(x, self.data[-1]['distance_to_cluster'])
        print(f'Seuil: {self.r} || Outlier: {isOutlier} ||dist_cluster {dist_to_cluster}|| dist_discord: {self.data[-1]["distance_to_discord"]} || {x} || ')
        if isOutlier:
            if isCandidate:
                # print('discord')
                self.discords.append(x)
                # self._ajust_threshold()
                if self.training_period > 0:
                    return -1
                return min_dist_if_discord if min_dist_if_discord != float('inf') else 1
            else:
                self.cluster_manager.add_new_cluster(x)

        if self.training_period > 0:
            return -1
        return 0

    def test(self, T, w):
        """_summary_

        Args:
                T (_type_): _description_
                w (_type_): _description_
        """
        S = [*range(0, len(T), int(w/2))]
        to_remove = []
        for idx, s in enumerate(S):
            if (len(T) < S[idx]+w/2):
                to_remove.append(s)
                # S.remove(s)  # to correct later
        for e in to_remove:
            S.remove(e)
        C_score = []
        for s in S:
            C_score.append(self.score_one(T[s:s+w//2]))

        return self.discords, S, C_score, self.cluster_manager.clusters

df = pd.read_csv("dataset/nab-data/realKnownCause/ambient_temperature_system_failure.csv", usecols=['value'])

data = np.array([0.3, 2, 1.2, 0, 2, 0.9, 0, 2.7, 1, 0.8, 2, 1.5,0.1, 2, 1, 0.3, 3, 1.2, 0.7, 2.2, 1, 0, 10, 0,0, 2, 1,0, 2, 1,-10,5,2])

pip install plotly

import matplotlib.pyplot as plt
plt.plot(data)

D = DragStream(r=2, nbr_cluster=3, training_period=5, p=3)
discords, S, C_score, clusters = D.test(data, 6)

data.shape

scores = []
for i in C_score:
    for _ in range(3):
        scores.append(i)
print(scores)

print(np.where(df_data['scores'] >= 1))

df_data = pd.DataFrame({
    'points': data,
    'scores': [0 if i<1 else 1 for i in scores],
    'anomalies': [np.nan if ele<1 else data[i] for i, ele in enumerate(scores)]
})
import plotly.graph_objs as go
from plotly.offline import init_notebook_mode, iplot
init_notebook_mode()


fig = go.Figure()
# Full line
fig.add_scattergl(x=df_data.index, y=df_data['points'], line={'color': 'gray'})

# Above threshhgold
fig.add_scattergl(x= df_data.index, y=df_data['anomalies'], line={'color': 'red'})

fig.add_scatter(x=S, y=df_data['points'][S])


iplot(fig)

import matplotlib.pyplot as plt
print(len(C_score))
print(D.data)
print(clusters)
print(f'S: {S}')
plt.scatter(range(len(C_score)),C_score)